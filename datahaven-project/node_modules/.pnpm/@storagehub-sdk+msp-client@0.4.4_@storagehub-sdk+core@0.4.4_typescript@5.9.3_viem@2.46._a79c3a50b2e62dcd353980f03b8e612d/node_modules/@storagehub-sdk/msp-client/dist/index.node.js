import{HttpClient as $}from"@storagehub-sdk/core";import{getAddress as M}from"viem";var l=class{ctx;sessionProviderRef;constructor(e,t){this.ctx=e,this.sessionProviderRef=t}async withAuth(e){let n=(await this.sessionProviderRef.current())?.token;return n?e?{...e,Authorization:`Bearer ${n}`}:{Authorization:`Bearer ${n}`}:e}normalizePath(e){return e.replace(/^\/+|\/{2,}/g,(t,n)=>n===0?"":"/")}};var B=10,T=100,y=class extends l{getNonce(e,t,n,s,i){return this.ctx.http.post("/auth/nonce",{body:{address:e,chainId:t,domain:n,uri:s},headers:{"Content-Type":"application/json"},...i?{signal:i}:{}})}getMessage(e,t,n,s){return this.ctx.http.post("/auth/message",{body:{address:e,chainId:t,uri:n},headers:{"Content-Type":"application/json"},...s?{signal:s}:{}})}async verify(e,t,n){return await this.ctx.http.post("/auth/verify",{body:{message:e,signature:t},headers:{"Content-Type":"application/json"},...n?{signal:n}:{}})}async SIWE(e,t,n,s=B,i){let{account:r,address:o,chainId:a}=await this.resolveAccount(e,"SIWE"),{message:p}=await this.getNonce(o,a,t,n,i);return this.signAndVerifyWithRetry(e,r,p,s,i,"SIWE")}async SIWX(e,t,n=B,s){let{account:i,address:r,chainId:o}=await this.resolveAccount(e,"SIWX"),{message:a}=await this.getMessage(r,o,t,s);return this.signAndVerifyWithRetry(e,i,a,n,s,"SIWX")}async resolveAccount(e,t){let n=e.account,s=typeof n=="string"?n:n?.address;if(!s||!n)throw new Error(`Wallet client has no active account; set wallet.account before calling ${t}`);let i=M(s),r=await e.getChainId();return{account:n,address:i,chainId:r}}async signAndVerifyWithRetry(e,t,n,s,i,r){let o=await e.signMessage({account:t,message:n}),a;for(let p=0;p<s;p++)try{return await this.verify(n,o,i)}catch(d){a=d,await this.delay(T)}throw a instanceof Error?a:new Error(`${r} verification failed`)}async delay(e){await new Promise(t=>setTimeout(t,e))}async getProfile(e){let t=await this.withAuth();return this.ctx.http.get("/auth/profile",{...t?{headers:t}:{},...e?{signal:e}:{}})}};import{ensure0xPrefix as u,parseDate as H}from"@storagehub-sdk/core";function C(c){return c.type==="file"?{name:c.name,type:c.type,sizeBytes:c.sizeBytes,fileKey:u(c.fileKey),status:c.status,uploadedAt:H(c.uploadedAt)}:{name:c.name,type:c.type,children:(c.children??[]).map(C)}}var f=class extends l{async listBuckets(e){let t=await this.withAuth();return(await this.ctx.http.get("/buckets",{...t?{headers:t}:{},...e?{signal:e}:{}})).map(s=>({bucketId:u(s.bucketId),name:s.name,root:u(s.root),isPublic:s.isPublic,sizeBytes:s.sizeBytes,valuePropId:u(s.valuePropId),fileCount:s.fileCount}))}async getBucket(e,t){let n=await this.withAuth(),s=`/buckets/${encodeURIComponent(e)}`,i=await this.ctx.http.get(s,{...n?{headers:n}:{},...t?{signal:t}:{}});return{bucketId:u(i.bucketId),name:i.name,root:u(i.root),isPublic:i.isPublic,sizeBytes:i.sizeBytes,valuePropId:u(i.valuePropId),fileCount:i.fileCount}}async getFiles(e,t){let n=await this.withAuth(),s=`/buckets/${encodeURIComponent(e)}/files`,i=await this.ctx.http.get(s,{...n?{headers:n}:{},...t?.signal?{signal:t.signal}:{},...t?.path?{query:{path:this.normalizePath(t.path)}}:{}}),o=("files"in i?i.files:[i.tree]).map(C),a=o[0];return{bucketId:u(i.bucketId),files:o,...a?{tree:a}:{}}}};import{ensure0xPrefix as h,FileMetadata as E,FileTrie as z,hexToBytes as P,initWasm as F,parseDate as N}from"@storagehub-sdk/core";var g=class extends l{async getFileInfo(e,t,n){let s=await this.withAuth(),i=`/buckets/${encodeURIComponent(e)}/info/${encodeURIComponent(t)}`,r=await this.ctx.http.get(i,{...s?{headers:s}:{},...n?{signal:n}:{}});return{fileKey:h(r.fileKey),fingerprint:h(r.fingerprint),bucketId:h(r.bucketId),location:r.location,size:BigInt(r.size),isPublic:r.isPublic,uploadedAt:N(r.uploadedAt),status:r.status,blockHash:h(r.blockHash),...r.txHash?{txHash:h(r.txHash)}:{}}}async uploadFile(e,t,n,s,i,r){await F();let o=`/buckets/${encodeURIComponent(e)}/upload/${encodeURIComponent(t)}`,a=await this.withAuth(),p=await this.coerceToFormPart(n),d=p.size,w=await this.computeFileFingerprint(p),x=await this.formFileMetadata(s,e,i,w,BigInt(d)),S=await this.computeFileKey(x),A=P(t);if(S.length!==A.length||!S.every((U,W)=>U===A[W]))throw new Error(`Computed file key ${S.toString()} does not match provided file key ${A.toString()}`);let v=x.encode(),m=new FormData,k=new Blob([new Uint8Array(v)],{type:"application/octet-stream"});return m.append("file_metadata",k,"file_metadata"),m.append("file",p,"file"),await this.ctx.http.put(o,a?{body:m,headers:a}:{body:m})}async downloadFile(e,t){let n=`/download/${encodeURIComponent(e)}`,s={Accept:"*/*"};if(t?.range){let{start:r,end:o}=t.range,a=`bytes=${r}-${o??""}`;s.Range=a}let i=await this.withAuth(s);try{let r=await this.ctx.http.getRaw(n,{...i?{headers:i}:{},...t?.signal?{signal:t.signal}:{}});if(!r.body)throw new Error("Response body is null - unable to create stream");let o=r.headers.get("content-type"),a=r.headers.get("content-range"),p=r.headers.get("content-length"),d=p!==null?Number(p):void 0,w=typeof d=="number"&&Number.isFinite(d)?d:null;return{stream:r.body,status:r.status,contentType:o,contentRange:a,contentLength:w}}catch(r){if(this.isHttpError(r))return{stream:this.createEmptyStream(),status:r.status,contentType:null,contentRange:null,contentLength:null};throw r}}isHttpError(e){return e!==null&&typeof e=="object"&&"status"in e&&typeof e.status=="number"}createEmptyStream(){return new ReadableStream({start(e){e.close()}})}async coerceToFormPart(e){if(typeof Blob<"u"&&e instanceof Blob)return e;if(e instanceof Uint8Array)return new Blob([e.buffer]);if(typeof ArrayBuffer<"u"&&e instanceof ArrayBuffer)return new Blob([e]);if(e instanceof ReadableStream){let t=e.getReader(),n=[],s=0;try{for(;;){let{done:o,value:a}=await t.read();if(o)break;a&&(n.push(a),s+=a.length)}}finally{t.releaseLock()}let i=new Uint8Array(s),r=0;for(let o of n)i.set(o,r),r+=o.length;return new Blob([i],{type:"application/octet-stream"})}return new Blob([e],{type:"application/octet-stream"})}async computeFileFingerprint(e){let t=new z,n=new Uint8Array(await e.arrayBuffer()),s=1024,i=0;for(;i<n.length;){let r=Math.min(i+s,n.length),o=n.slice(i,r);t.push_chunk(o),i=r}return t.get_root()}async formFileMetadata(e,t,n,s,i){let r=P(e),o=P(t),a=new TextEncoder().encode(n);return await F(),new E(r,o,a,i,s)}async computeFileKey(e){return await F(),e.getFileKey()}};import{ensure0xPrefix as I}from"@storagehub-sdk/core";var b=class extends l{getHealth(e){return this.ctx.http.get("/health",{...e?{signal:e}:{}})}async getInfo(e){let t=await this.ctx.http.get("/info",{...e?{signal:e}:{}});return{client:t.client,version:t.version,mspId:I(t.mspId),multiaddresses:t.multiaddresses,ownerAccount:I(t.ownerAccount),paymentAccount:I(t.paymentAccount),status:t.status,activeSince:t.activeSince,uptime:t.uptime}}getStats(e){return this.ctx.http.get("/stats",{...e?{signal:e}:{}})}getValuePropositions(e){return this.ctx.http.get("/value-props",{...e?{signal:e}:{}})}async getPaymentStreams(e){let t=await this.withAuth();return this.ctx.http.get("/payment_streams",{...t?{headers:t}:{},...e?{signal:e}:{}})}};var R=class c extends l{config;context;auth;buckets;files;info;constructor(e,t,n){let s={config:e,http:t};super(s,n),this.config=e,this.context=s,this.auth=new y(this.context,n),this.buckets=new f(this.context,n),this.files=new g(this.context,n),this.info=new b(this.context,n)}static async connect(e,t=async()=>{}){if(!e?.baseUrl)throw new Error("MspClient.connect: baseUrl is required");let n=new $({baseUrl:e.baseUrl,...e.timeoutMs!==void 0&&{timeoutMs:e.timeoutMs},...e.defaultHeaders!==void 0&&{defaultHeaders:e.defaultHeaders},...e.fetchImpl!==void 0&&{fetchImpl:e.fetchImpl}}),s={current:t};return new c(e,n,s)}setSessionProvider(e){this.sessionProviderRef.current=e}};export{R as MspClient};
//# sourceMappingURL=index.node.js.map
